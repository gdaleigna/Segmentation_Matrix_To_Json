import numpy as np
import random
import time
from collections import deque
from operator import eq

start_time = time.time()


# CLASS
class SegmentationCoordinate:
    x: int
    y: int
    z: int

    def __init__(self, x=None, y=None, z=None):
        self.x = x
        self.y = y
        self.z = z

    def print(self):
        print("X: ", self.x, ", Y: ", self.y, ", Z: ", self.z, sep="")


class SegmentationMatrix:
    size_x: int
    size_y: int
    size_z: int
    mode: int
    numberOfObjects: int

    def __init__(self):
        self.size_x = 3
        self.size_y = 3
        self.size_z = 2
        self.mode = 1
        self.numberOfObjects = -1
        self.input_matrix = np.zeros((self.size_z, self.size_x, self.size_y, self.mode))
        self.segmentation_objects = [[]]

    def copy_matrix_from_numpy_array(self, numpy_array):
        if numpy_array.ndim == 4:
            self.size_x = np.shape(numpy_array)[1]
            self.size_y = np.shape(numpy_array)[2]
            self.size_z = np.shape(numpy_array)[0]
            self.mode = np.shape(numpy_array)[3]
            self.input_matrix = numpy_array
        else:
            print("ERROR: Incompatible Matrix")

    def create_new_matrix(self, x, y, z, mode):
        self.size_x = x
        self.size_y = y
        self.size_z = z
        self.mode = mode
        self.input_matrix = np.zeros((z, x, y, mode))

    def generate_random_segmentation(self):
        for i in range(0, self.size_z):
            for j in range(0, self.size_x):
                for k in range(0, self.size_y):
                    self.input_matrix[i][j][k][0] = 1 if random.randint(0, 3) == 1 else 0

    def display_input_matrix_with_selected_mode(self, mode):
        print("Segmentation Size is", self.size_x, "x", self.size_y, "with", self.size_z, "image(s) and", self.mode,
              "mode(s).")
        for i in range(0, self.size_z):
            for j in range(0, self.size_x):
                for k in range(0, self.size_y):
                    if self.input_matrix[i][j][k][mode] > 0:
                        print(int(self.input_matrix[i][j][k][mode]), end='')
                    else:
                        print(".", end='')

                    print(" ", end='')

                print()
            print()

    def print_all_coordinates(self):
        all_coordinates = []

        for i in range(0, self.size_z):
            for j in range(0, self.size_x):
                for k in range(0, self.size_y):
                    if self.input_matrix[i][j][k][0] > 0:
                        all_coordinates.append(SegmentationCoordinate(k, j, i))

        for i in all_coordinates:
            i.print()

    def get_item(self, array, index):
        z, x, y = index
        return array[z][x][y]

    def get_next(self, node, offset):
        z, x, y = node
        z_offset, x_offset, y_offset = offset
        return z + z_offset, x + x_offset, y + y_offset

    def is_valid(self, array, index):
        z, x, y = index
        return 0 <= z < array.shape[0] and 0 <= x < array.shape[1] and 0 <= y < array.shape[2]

    def find_proximity(self, array, adjacency, start, similar, mode):
        match = self.get_item(array, start)
        block = {start}
        visit = deque(block)
        child = dict(BFS=deque.popleft, DFS=deque.pop)[mode]
        while visit:
            node = child(visit)
            for offset in adjacency:
                index = self.get_next(node, offset)
                if index not in block:
                    block.add(index)
                    if self.is_valid(array, index):
                        value = self.get_item(array, index)
                        if similar(value, match):
                            visit.append(index)
            yield node

    def find_independent_objects_from_adjacency(self):
        tmp_seg = self.input_matrix

        # # This adjacency map excludes the diagonal vertices.
        # adjacency = (0, -1, +1), \
        #             (-1, -1, 0), \
        #             (0, -1, 0), \
        #             (+1, -1, 0), \
        #             (0, -1, -1), \
        #             (-1, 0, +1), \
        #             (0, 0, +1), \
        #             (+1, 0, +1), \
        #             (-1, 0, 0), \
        #             (+1, 0, 0), \
        #             (-1, 0, -1), \
        #             (0, 0, -1), \
        #             (+1, 0, -1), \
        #             (0, +1, +1), \
        #             (-1, +1, 0), \
        #             (0, +1, 0), \
        #             (+1, +1, 0), \
        #             (0, +1, -1)

        # This adjacency map includes the diagonal vertices.
        adjacency = (-1, -1, +1), \
                    (0, -1, +1), \
                    (+1, -1, +1), \
                    (-1, -1, 0), \
                    (0, -1, 0), \
                    (+1, -1, 0), \
                    (-1, -1, -1), \
                    (0, -1, -1), \
                    (+1, -1, -1), \
                    (-1, 0, +1), \
                    (0, 0, +1), \
                    (+1, 0, +1), \
                    (-1, 0, 0), \
                    (+1, 0, 0), \
                    (-1, 0, -1), \
                    (0, 0, -1), \
                    (+1, 0, -1), \
                    (-1, +1, +1), \
                    (0, +1, +1), \
                    (+1, +1, +1), \
                    (-1, +1, 0), \
                    (0, +1, 0), \
                    (+1, +1, 0), \
                    (-1, +1, -1), \
                    (0, +1, -1), \
                    (+1, +1, -1)

        start = 0, 0, 0
        similar = eq
        print(list(self.find_proximity(tmp_seg, adjacency, start, similar, 'BFS')))



# MAIN
seg = SegmentationMatrix()
# seg.copy_matrix_from_numpy_array(segmentation_matrix)
seg.create_new_matrix(8, 8, 3, 1)
seg.generate_random_segmentation()
seg.display_input_matrix_with_selected_mode(0)
# seg.print_all_coordinates()

# TIMER
print("--- %s seconds ---" % (time.time() - start_time))
